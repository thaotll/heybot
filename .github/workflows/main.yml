name: Build, Scan & Update Manifests for ArgoCD

on: [push]

env:
  USER: "thaotll"
  IMAGE_NAME: "heybot-with-trivy-output"
  HELM_CHART_PATH: "./helm/heybot"
  HELM_RELEASE_NAME: "heybot"
  K8S_MANIFEST_PATH: "k8s"

jobs:
  build_scan_and_update_manifests:
    runs-on: ubuntu-latest

    steps:
      # Checkout the code with write permission
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          fetch-depth: 0
        
      # Get current commit ID
      - name: Get current commit ID
        id: get_commit_id
        run: echo "CURRENT_COMMIT_ID=$(git rev-parse HEAD)" >> $GITHUB_ENV

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      # Build and push the Docker image with current commit ID
      - name: Build and push Docker image
        run: |
          docker build --no-cache \
            --build-arg CURRENT_COMMIT_ID=${{ env.CURRENT_COMMIT_ID }} \
            -t ghcr.io/${{ env.USER }}/${{ env.IMAGE_NAME }}:${{ env.CURRENT_COMMIT_ID }} \
            -t ghcr.io/${{ env.USER }}/${{ env.IMAGE_NAME }}:latest .
          
          docker push ghcr.io/${{ env.USER }}/${{ env.IMAGE_NAME }}:${{ env.CURRENT_COMMIT_ID }}
          docker push ghcr.io/${{ env.USER }}/${{ env.IMAGE_NAME }}:latest

      - name: Create directory for scan results
        run: mkdir -p ${{ github.workspace }}/analysis_results

      - name: Run Security Scans (Trivy & OWASP via main.py)
        id: security_scan
        run: |
          echo "Running security scans in Docker container..."
          docker run --rm \
            -e CURRENT_COMMIT_ID=${{ env.CURRENT_COMMIT_ID }} \
            -e DISCORD_WEBHOOK_URL=${{ secrets.DISCORD_WEBHOOK_URL }} \
            -e MODEL_HUMOR_PATH=/app/model_humor.txt \
            -e DEEPSEEK_API_KEY=${{ secrets.DEEPSEEK_API_KEY }} \
            -v ${{ github.workspace }}/analysis_results:/app/analysis \
            ghcr.io/${{ env.USER }}/${{ env.IMAGE_NAME }}:${{ env.CURRENT_COMMIT_ID }} \
            python /app/main.py

          echo "Scan script finished. Listing contents of analysis_results:"
          ls -lA ${{ github.workspace }}/analysis_results

          # Überprüfe das Ergebnis des Scans aus der generierten latest.json
          # Stelle sicher, dass latest.json existiert, bevor jq darauf zugreift.
          LATEST_JSON_PATH="${{ github.workspace }}/analysis_results/latest.json"
          if [ ! -f "$LATEST_JSON_PATH" ]; then
            echo "::error::Scan result file latest.json not found in analysis_results!"
            echo "Expected at: $LATEST_JSON_PATH"
            exit 1
          fi
          
          echo "Contents of latest.json:"
          cat "$LATEST_JSON_PATH"

          if jq -e '.securityScans[] | select(.status=="error")' "$LATEST_JSON_PATH"; then
            echo "::warning::Security scan found critical errors according to latest.json."
          elif jq -e '.securityScans[] | select(.status=="warning")' "$LATEST_JSON_PATH"; then
            echo "::warning::Security scan found warnings according to latest.json."
            # Workflow wird bei Warnungen nicht abgebrochen, kann bei Bedarf geändert werden.
          else
            echo "Security scan completed without critical errors or warnings reported in latest.json."
          fi

      - name: Upload scan results
        if: always() # Ensure results are uploaded even if the previous step fails (e.g. due to jq errors if file is malformed but exists)
        uses: actions/upload-artifact@v4
        with:
          name: scan-results-${{ env.CURRENT_COMMIT_ID }}
          path: ${{ github.workspace }}/analysis_results

      - name: Update Kubernetes Manifests with Helm
        run: |
          echo "Updating image tag in Helm chart to ${{ env.CURRENT_COMMIT_ID }} for all relevant deployments (including analyzer job)"
          
          # Ensure base k8s manifest path exists
          mkdir -p ${{ env.K8S_MANIFEST_PATH }}
          
          # Remove specific files and directories in K8S_MANIFEST_PATH that Helm will manage/regenerate.
          # This prevents the mv command from failing on non-empty directories like 'tests'
          # and ensures old versions of Helm-managed files are removed, while keeping other YAMLs.
          echo "Cleaning up previously Helm-generated files in ${{ env.K8S_MANIFEST_PATH }} that are managed by this chart"
          rm -f ${{ env.K8S_MANIFEST_PATH }}/deployment.yaml 
          rm -f ${{ env.K8S_MANIFEST_PATH }}/analyzer-job.yaml 
          rm -f ${{ env.K8S_MANIFEST_PATH }}/service.yaml
          rm -f ${{ env.K8S_MANIFEST_PATH }}/serviceaccount.yaml
          # Add other specific files Helm might generate here if your chart evolves (e.g., ingress.yaml, hpa.yaml)
          # rm -f ${{ env.K8S_MANIFEST_PATH }}/ingress.yaml
          # rm -f ${{ env.K8S_MANIFEST_PATH }}/hpa.yaml
          rm -f ${{ env.K8S_MANIFEST_PATH }}/_helpers.tpl # Helm helper file
          rm -f ${{ env.K8S_MANIFEST_PATH }}/NOTES.txt    # Helm notes file
          rm -rf ${{ env.K8S_MANIFEST_PATH }}/tests       # Helm tests directory

          # Helm templates into its standard subdirectory structure within K8S_MANIFEST_PATH
          # e.g. k8s/heybot/templates/
          helm template ${{ env.HELM_RELEASE_NAME }} ./${{ env.HELM_CHART_PATH }} \
            --set image.tag=${{ env.CURRENT_COMMIT_ID }} \
            --set image.repository=ghcr.io/${{ env.USER }}/${{ env.IMAGE_NAME }} \
            --output-dir ${{ env.K8S_MANIFEST_PATH }}
            
          # Define the source path of the templated files
          TEMPLATED_FILES_SOURCE_PATH="${{ env.K8S_MANIFEST_PATH }}/${{ env.HELM_RELEASE_NAME }}/templates"
          ALTERNATIVE_TEMPLATED_FILES_SOURCE_PATH="${{ env.K8S_MANIFEST_PATH }}/${{ env.HELM_RELEASE_NAME }}" # For Helm versions < 3.1 or certain structures

          if [ -d "$TEMPLATED_FILES_SOURCE_PATH" ]; then
            echo "Moving templated files from $TEMPLATED_FILES_SOURCE_PATH to ${{ env.K8S_MANIFEST_PATH }}"
            # Move all contents, including subdirectories like 'tests'
            mv $TEMPLATED_FILES_SOURCE_PATH/* ${{ env.K8S_MANIFEST_PATH }}/
            # Remove the now-empty chart-name directory structure
            rm -rf "${{ env.K8S_MANIFEST_PATH }}/${{ env.HELM_RELEASE_NAME }}"
          elif [ -d "$ALTERNATIVE_TEMPLATED_FILES_SOURCE_PATH" ]; then
            echo "Moving templated files from $ALTERNATIVE_TEMPLATED_FILES_SOURCE_PATH to ${{ env.K8S_MANIFEST_PATH }}"
            mv $ALTERNATIVE_TEMPLATED_FILES_SOURCE_PATH/* ${{ env.K8S_MANIFEST_PATH }}/
            rm -rf "${{ env.K8S_MANIFEST_PATH }}/${{ env.HELM_RELEASE_NAME }}"
          else
            echo "Error: Helm output directory not found as expected. Listing content of ${{ env.K8S_MANIFEST_PATH }} for debugging:"
            ls -R ${{ env.K8S_MANIFEST_PATH }}
            exit 1
          fi
          
          echo "Generated manifests in ${{ env.K8S_MANIFEST_PATH }}:"
          ls -R ${{ env.K8S_MANIFEST_PATH }}

      - name: Commit and push manifest changes
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git add ${{ env.K8S_MANIFEST_PATH }}/*
          
          if ! git diff --staged --quiet; then
            git commit -m "Update image to ${{ env.IMAGE_NAME }}:${{ env.CURRENT_COMMIT_ID }} via Helm [skip ci]"
            git push
          else
            echo "No manifest changes to commit."
          fi